MAIN.C

main(c) llama a HAL_Init() y luego a SystemClock_Config().
Con eso, quedan configurados SysTick (1ms por defecto) y SystemCoreClock (frecuencia del CPU)

Inicializa periféricos (GPIO, UART) y llama a app_init().
Se queda en el while(1) llamando a app_update().

APP.C

const task_cfg_t task_cfg_list[] = {
  {task_sensor_init, task_sensor_update, NULL},
  {task_system_init, task_system_update, NULL},
  {task_actuator_init, task_actuator_update, NULL}
};

en app_init() se llama a los task_xxx_init() y se inicializan contadores/estadísticos WCET.

El pulso temporal lo da HAL_SYSTICK_Callback(), ahí se incrementa g_app_tick_cnt.

En app_update():
	Se chequea si hay tiempo disponible mirando g_app_tick_cnt. Si hay, lo consume
	(decrementa) y ejecuta una pasada por todas las tareas (sensor -> system -> actuator)
	
	Mide tiempo de cada tarea con DWT para WCET y acumula en g_app_runtime_us el runtime total del ciclo.
	
	
g_app_runtime_us: cuánto tardó todo el ciclo (la pasada por las tres tareas). Se mira en "Live Expressions" mientras corre.

WCET por tarea: es el peor caso observado para cada task_xxx_update(). [WCET] = uS.

LOGGER_INFO(): si me logueo dentro de una tarea, suben g_app_runtime_us y el WCET. Lo puedo mostrar con logs y sin logs.


STATECHARTS:

task_sensor_update(): implementa el Sensor Statechart (leer botón)
task_system_update(): implementa el System Statechart (lógica/algoritmo que reacciona a eventos del sensor)
task_actuator_update(): implementa el Actuator Statechart (controlar LED)

Patrón: switch(state) + if por cada transición, y cuando corresponde
		se emite una señal a la siguiente tarea con una función del
		tipo put_event_task_...
		
void task_system_update(void *p) {
  switch(system_dta.state) {
    case SYS_IDLE:
      // if(evento) { system_dta.state = SYS_ON; put_event_task_actuator(EV_LED_ON); }
      break;
    case SYS_ON:
      // if(timeout || evento) { system_dta.state = SYS_IDLE; put_event_task_actuator(EV_LED_OFF); }
      break;
    // ...
  }
}
		










