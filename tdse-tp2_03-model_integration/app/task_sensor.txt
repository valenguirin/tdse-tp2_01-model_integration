El sensor implementa el statechart del botón y publica eventos al System
cuando detecta down/up. Se apoya en:
	Un arreglo de configuración por botón (qué pin leer, pressed, cuánto tick,
	qué evento mandar al System en cada transición)
	
	Un arreglo de datos por botón (tick, estado y último evento leído)
	
Estructuras y arrays:

Tipos en TASK_SENSOR_ATTRIBUTE.H:
	
	Eventos del sensor: EV_BTN_XX_UP, EV_BTN_XX_DOWN
	Estados del sensor: ST_BTN_XX_UP, ST_BTN_XX_FALLING, _ST_BTN_XX_DOWN, ST_BTN_XX_RISING
	Configuración por botón (task_sensor_cfg_t): id, puerto/pin, pressed, tick_max y qué señal mandar al System en up/down
	Datos por botón (task_sensor_dta_t): tick, state, event.
	
Instancias en TASK_SENSOR.C:

	Configuración: mapea el botón A a su pin y define qué evento mandar al System: 
	signal_up = EV_SYS_IDLE, signal_down = EV_SYS_LOOP_DET.
	
	Datos: inicia tick = 0, state = ST_BTN_XX_UP, event = EV_BTN_XX_UP
	
	Constantes de tiempo: DEL_Btn_XX_MIN/MED/MAX
	
	
Planificación "updated by time" (no bloqueante):

El update del sensor se habilita con un tick implementado por SysTick.
En task_sensor_update():
	
	1) Entra, consume un tick si hay (g_task_sensor_tick_cnt--) y marca que debe actualizar.
	
	2) Mientras haya trabajo pendiente, ejecuta el statechart (task_sensor_statechart()) y vuelve
	a chequear si quedaron más ticks acumulados.
	
	RESULTADO: no hay delay dentro del statechart, si SysTick tiró varios ticks, el sensor se pone al día sin bloquear.
	

Lógica del statechart (código C vs diagrama):

TASK_SENSOR_STATECHART.C:
	
	1) Lee GPIO y genera evento local: si el nivel leído coincide con la polaridad pressed => EV_BTN_XX_DOWN,
	si no, => EV_BTN_XX_UP
	
	2) Estados implementados:
		ST_BTN_XX_UP: al ver EV_BTN_XX_DOWN, publica al System signal_down y pasa a ST_BTN_XX_DOWN.
		ST_BTN_XX_DOWN: al ver EV_BTN_XX_UP, publica al System signal_up y vuelve a ST_BTN_XX_UP.
		
		La publicación se hace con put_event_task_system()
		
	3) FALLING/RISING están vacíos en esta base (todavía no hacen debounce). El default reinicializa tick/estado/evento.
	
	
State Transition Table:

De UP -> FALLING con EV_BTN_XX_DOWN: setea tick = TICK_MAX. Mientras tick > 0, queda en FALLING
y tick--. Si el botón se estabiliza en DOWN con tick = 0, pasa a DOWN y publica al System.

De DOWN -> RISING con EV_BTN_XX_UP: análogo.

Eventos que salen hacia system:

Al presionar (down) se emite EV_SYS_LOOP_DET, al soltar (up) se emite EV_SYS_IDLE. Eso se toma de task_sensor_cfg_list[]


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	